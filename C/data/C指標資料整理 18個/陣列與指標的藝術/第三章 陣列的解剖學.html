<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=big5" http-equiv="content-type">
  <title>前 言</title>
</head>
<body>
C/C++的陣列不同於VB等語言的陣列，是有層次的，這個層次指的不是維度，而是象俄羅斯有名的套娃一樣，一維套一維，亦即陣列的嵌套，陣列的元素也是陣列，VB等語言的陣列與之相比更像一個平面。<br>
<br>
&nbsp;<br>
<br>
陣列嵌套這個現象從其它語言的角度來看有點奇特，但其實原因也很簡單。C/C++的物件 模型並不視陣列為某種數值的簡單群集   ，而是物件 的聚集，每個元素都
是一個物件 。元素為整數物件 ，就是整數陣列，為浮點數物件 ，就是浮點數陣列。然而，陣列本身也是一種物件 ，因此一個陣列也能作為另一個陣列的元素。當某個
一維陣列以一維陣列作為元素時，這個一維陣列每個元素都具有陣列型別，這個一維陣列其實是二維陣列，同理，一個以二維陣列作為元素的一維陣列其實是三維數
組。因此，使用C/C++陣列的時候應該用陣列嵌套的觀點去看待。有人據此認為，C/C++的陣列不是真正的陣列，還有的認為C/C++沒有多維陣列，這
些觀點都有失偏頗，與其它語言的陣列相比，兩者只是同一事物的不同實體，是實現方法的不同，而本質是一樣的，C/C++的陣列嵌套可視為對陣列概念的發
展。<br>
<br>
&nbsp;<br>
<br>
現在來看看陣列的定義：<br>
<br>
&nbsp;<br>
<br>
6.5.4.2 Array declarators<br>
<br>
&nbsp;<br>
<br>
Semantics<br>
<br>
&nbsp;<br>
<br>
If, in the declaration &ldquo;T Dl.&rdquo; Dl has the form<br>
<br>
D [ constant expressionopt ]<br>
<br>
&nbsp;<br>
<br>
這個定義非常簡單，其中T代表元素型別，D代表標識符，constant
expression必須為大於0的常數運算式，opt表示可選，即[]中的內容可以為空，當[]為空時叫不完整型別，表示這個陣列物件 的長度未知，不完
整陣列型別可以在程式的某個地方補充完整。細心的人馬上就會發現，從形式上看，怎麼只有一維陣列的定義？這個形式如何定義多維陣列？剛才說過，C/C++
的陣列是陣列的嵌套，因此多維陣列的定義也反映了這個本質。多維陣列的定義是通過嵌套的一維陣列定義構造的。對於一維陣列：<br>
<br>
&nbsp;<br>
<br>
T D[M]<br>
<br>
&nbsp;<br>
<br>
當元素為一維陣列T[N]時，元素的型別也為陣列型別，用T[N]代替T，則為：<br>
<br>
&nbsp;<br>
<br>
T[N] D[M]<br>
<br>
&nbsp;<br>
<br>
這個語法結構不符合C/C++陣列定義的語法形式，將[N]移動到[M]後，就是正式的二維陣列的定義了：<br>
<br>
&nbsp;<br>
<br>
T D[M][N]<br>
<br>
&nbsp;<br>
<br>
其中D[0]---D[M-1]都是一維陣列，具有陣列型別T[N]。各種維度的多維陣列可以用同樣的嵌套方法構造出來。<br>
<br>
&nbsp;<br>
<br>
一個一維陣列T[M]，經過陣列到指標的轉換後，型別轉換為T*，二維陣列T[M][N]轉換為指標後，型別轉換為T ( *
)[N]，有些初學者對T( *
)[N]這種形式較難理解，怎麼多了一維，形式就有這麼大的差別呢，其實原理還是跟嵌套有關，二維陣列為一維陣列的嵌套，元素為陣列型別，因此用T[N]
代替T，則二維陣列轉換之後的指標型別為T[N] *，將[N]移動到*的右邊，就是T*[N]，由於[]的優先級比*高，因此需要加括號，就成為T(
* )[N]了，否則就不是指標型別，而成了指標陣列型別了。<br>
<br>
&nbsp;<br>
<br>
圍繞陣列名，存在一些有趣的運算式，下面的內容通過討論這些運算式中較為重要的幾個，來加深對陣列的理解。對於二維陣列：<br>
<br>
&nbsp;<br>
<br>
T a[M][N]<br>
<br>
&nbsp;<br>
<br>
a： 運算式中的a的型別轉換為T ( * )[N]，代表陣列的首位址；<br>
<br>
&amp;a：是一個指向二維陣列物件 的指標，型別為T ( *
)[M][N]。在C標准出現之前，一些早期的實現並不允許&amp;a，因為這些編譯器認為此時的a轉換為一個右值，而&amp;運算符要求一個左值，
因此非法。C標准委員會鑒於物件 的概念已經得到了擴展，而且允許&amp;a並沒有害處，因此把&amp;運算符作為一個例外寫進了陣列到指標的轉換條款
中。這種情況下的a代表陣列物件 ，&amp;a表示對陣列物件 取位址，因此&amp;a的結果跟a是相同的，但型別不同。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
筆者曾經見過某些觀點認為，&amp;a才是陣列的首位址，不是a。這個觀點初看起來似乎很有道理，一個陣列物件 的引用，不正是首位址嗎？但實際上這種論
述是不符合標准的，陣列到指標的轉換條款規定，當產生一個points to the initial element of the array
object的時候，其前提是由array of type到pointer to type的轉換，但&amp;a的型別屬於pointer to
array of type，不是pointer to type，因此真正代表陣列首位址的是a本身，不是&amp;a。<br>
<br>
&amp;a[0][0]：這是陣列首元素的位址。&amp;a[0][0]常常被誤解為陣列a的首位址，其實a[0][0]只不過由於位元置特殊，其位址
值才與a相同，&amp;a[0][0]是一個T型別物件 的引用，不是一個陣列物件 的引用，而且其型別不是由array of
type轉換得來的，因此其意義不是陣列首位址。<br>
<br>
a[i]（其中 i &gt;= 0 &amp;&amp; i &lt; M）：從陣列嵌套的觀點來看，a是一個一維陣列，元素的型別為陣列型別，因此a[i]的型別為T[N]，在運算式中轉換為T*，是第i個一維陣列的首位址。<br>
<br>
a + 1：a隱式轉換為指標型別T( * )[N]然後加1，請記住指標加法是以指標指向物件 的大小為步長的，因此a + 1將跨過N * sizeof( T )個位元組。<br>
<br>
&amp;a + 1：與a + 1同理，&amp;a型別為T( * )[M][N]，因此&amp;a + 1的步長為M * N * sizeof( T )。<br>
<br>
<br>
本文來自CSDN博客，轉載請標明出處：http://blog.csdn.net/supermegaboy/archive/2009/11/23/4855010.aspx
</body>
</html>
