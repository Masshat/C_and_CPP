7.2.3字串與指標
　

　　1．字串與字串指標
　　字串是存放在字符陣列中的，對字符陣列中的字符逐個處理時，前面介紹的指標與陣列之間的關系完全適用於字符陣列。通常將字串作為一個整體來使用，用指標來處理字串更加方便。當用指向字串的指標來處理字串時，並不關心存放字串的陣列大小，而只關心是否已處理到字串的結束符。 


　　【例7.10】用指標實現字串拷貝。 
　# include <iostream.h>
　# include <string.h>
　void main(void)
　{ char *p1="I am a student" ;
　　char s1[30],s2[30];
　　strcpy( s1,p1); //用命令拷貝字串 
　　char *p2=s2; //將陣列s2首位址賦p2
　　for (;*p2++=*p1++;); //用指標拷貝字串
　　cout<<"s1="<<s1<<endl;
　　cout<<"s2="<<s2<<endl;
　}
　　執行後輸出：
　　s1= I am a student 
　　s2= I am a student
　

　　說明：
　　（1）編譯系統執行定義語句char *p1="I am a student" 時，首先為字串"I am a student "配置記憶體空間，然後將該記憶體空間首位址賦給指標變數p1。
　　（2）用指標變數拷貝字串程序是，先將指標變數p2指向字串陣列s2的首位址，然後通過賦值語句*p2=*p1將字符由字串s1中拷貝到s2中，再移動p1、p2到下一個字符單元，依次迴圈直到字串結束符'\0'為止，如圖7.8所示。全部拷貝程序用一個for語句完成。在for（;*p2++=*p1++;）語句中，運算式：　　　　

　　*p2++=*p1++ 等價於下列三條語句，
　　*p1=*p2; // s2[i]=s1[i]，將指標p1所指s1[i]賦給指標p1所指s2[i]。
　　p1++; //指標p1加1指向s1的下一個元素
　　p2++; //指標p2加1指向s2的下一個元素
　　上述語句不斷迴圈，直到p1指向結束字符'\0'=0時，for 語句因條件為假而結束。從而完成字串s1拷貝到字符陣列s2的任務。
　　（3）指標變數p1可以作為拷貝函式strcpy(s1,p1)的引數。
　　

　　2．字符型指標變數與字符陣列的區別
　　（1）配置記憶體
　　設有定義字符型指標變數與字符陣列的語句如下：
　　char *pc ,str[100];
　　則系統將為字符陣列str配置100個位元組的記憶體單元，用於存放100個字符。而系統只為指標變數pc配置4個儲存單元，用於存放一個記憶體單元的位址。
　　（2）初始化賦值含義
　　字符陣列與字符指標變數的初始化賦值形式相同，但其含義不同。例如：
　　char str[ ] ="I am a student ! " ,s[200];
　　char *pc="You are a student ! " ;
　　對於字符陣列，是將字串放到為陣列配置的儲存空間去，而對於字符型指標變數，是先將字串存放到記憶體，然後將存放字串的記憶體起始位址送到指標變數pc中。
　　（3）賦值方式
　　字符陣列只能對其元素逐個賦值，而不能將字串賦給字符陣列名。對於字符指標變數，字串位址可直接賦給字符指標變數。例如：
　　str="I love China! "; //字符陣列名str不能直接賦值，該語句是錯誤的。
　　pc="I love China! "; //指標變數pc可以直接賦字串位址，語句正確 
　　（4）輸入方式
　　可以將字串直接輸入字符陣列，而不能將字串直接輸入指標變數。但可將指標變數所指字串直接輸出。
　　例如： cin >> str //正確
　　cin >> pc //錯誤
　　cout<<pc //正確
　　（5）值的改變
　　在程式執行期間，字符陣列名表示的起始位址是不能改變的，而指標變數的值是可以改變的。例如：str=str+5; //錯誤
　　pc=str+5; //正確
　　小結字元陣列s[100] 指標變數pc
　　（1）配置記憶體 配置100個單元 配置4個單元。
　　（2）賦值含義字元串放到陣列儲存空間 先將字串存放到記憶體
　　將存放串的首位址送到pc中。
　　（3）賦值方式 只能逐個元素賦值 串位址可賦給pc
　　（4）輸入方式： 串直接輸入字符陣列 不能將字串直接輸入指標變數
　　（5）值的改變：字元陣列首位址不能改變 指標變數的值可以改變
由以上區別可以看出，在某些情況下，用指標變數處理字串，要比用陣列處理字串方便。

