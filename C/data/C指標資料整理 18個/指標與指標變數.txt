通常指標變數的使用是：先定義指標變數，後給指標變數賦值，最後引用指標變數。現說明如下：
　　（1）定義指標變數
　　在變數定義語句int *p, *p1, *q; 中用 * 定義的變數均為指標變數。因此該語句定義了名為p、p1與q三個整型指標變數。因為指標變數用於存放變數位址，而位址通常為4位元組，所以指標變數的長度均為4個位元組。
　　（2）指標變數賦值
　　指標變數定義後其值為亂數 ，若此亂數 為系統區的位址，則對該指標變數所指系統區某儲存單元進行賦值運算，將改變系統區該單元中內容，可能導致系統的崩潰。所以，指標變數定義後必須賦某個變數的位址或0。
　　從上面例子可以看出，給指標變數賦初值有三種情況：
　　第一種情況是用取位址運算符"&"將變數位址賦給指標變數。如：p=&a；
　　第二種情況是將一個指標變數中的位址賦給另一個指標變數，如：p1=p；
　　第三種情況是給指標變數賦空值0，如q=0；表示該指標變數不指向任何變數。
　　經過賦值後，使指標變數p、p1指向變數a，q不指向任何單元，如圖7.2所示。
　　（3）指標變數的引用
　　指標變數的引用是通過指標運算符"*"實現。在上例中，*p與*p1均表示變數a，因此，第一個輸出語句 cout<<*p 被執行後，輸出的是變數a的內容100。而賦值語句 *p1=200；是通過指標變數p1間接的將資料200賦給變數a，因此，第二個輸出語句中，a 、*p、 *p1同為賦值後變數a的內容200。
　　（4）指標變數初始化
　　指標變數可以象一般變數一樣，在定義指標變數時賦初值，如上例中，定義指標變數p的語句可寫成：int *p=&a; 

7.1.3 指標變數的運算


　　指標變數的運算有三種：賦值運算、關系運算與算術運算。
　　1．指標變數賦值運算
　　指標變數賦值運算就是將變數的位址賦給指標變數，上節內容已介紹過，現再舉一例加深讀者對指標變數賦值運算的理解。
　　【例7.2】定義三個整型變數a1、a2、a3，用指標變數完成a3=a1+a2的操作。再定義兩個實型變數b1、b2，用指標變數完成b1+b2的操作。
　# include <iostream.h>
　void main (void)
　{ int a1=1,a2=2,a3;
　　int *p1,*p2,*p3;
　　float b1=12.5,b2=25.5;
　　float *fp1,*fp2;
　　p1=&a1;
　　p2=&a2;
　　p3=&a3;
　　*p3= * p1 + *p2;
　　fp1=&b1;
　　fp2=&b2;
　　cout<<" *p1="<<*p1<<'\t'<<" *p2="<<*p2<<'\t' <<"*p1+*p2="<<*p3<<'\n';
　　cout<<"a1="<<a1<<'\t'<<" a2="<<a2<<'\t' <<"a1+a2="<<a3<<'\n';
　　cout<<"b1=" <<*fp1<<'\t'<<" b2="<<*fp2<<'\t'<<"b1+b2="<<*fp1+*fp2<<'\n';
　}
　

　　程式執行後，輸出：
　　*p1=1 *p2=2 *p1+ *p2=3
　　a1=1 a2=2 a1+a2=3
　　b1=12.5 b2=25.5 b1+b2=38
　　在此例中，經過指標變數賦值運算後，整型指標變數p1、p2、p3分別指向變數a1、a2、a3，因此，*p1=a1，*p2=a2，*p3=a3。所以，*p3= * p1 + *p2 操作就是a3=a1+a2 操作。如圖7.3(a)所示。

    2．指標變數的算術運算


　　指標變數的算術運算主要有指標變數的自加、自減、加n和減n操作。
　　（1）指標變數自加運算
　　指令格式：<指標變數>++;
　　指標變數自加運算並不是將指標變數值加1的運算，而是將指標變數指向下一個元素的運算。當計算機執行 <指標變數>++ 指令後，指標變數實際增加值為指標變數型別位元組數，即：<指標變數>=<指標變數>+sizeof(<指標變數型別>)。假設陣列a的首位址為1000，如圖7.4所示。

int *p=&a[0]; //p=1000，指向a[0]元素
　　p++; 
　　第一條語句將陣列a的首位址1000賦給指標變數p，使p=1000。第二條語句使p作自加運算：
　　p=p+sizeof(int)=p+4=1004，使p指向下一個元素a[1] 。

   （2）指標變數自減運算
　　指令格式：<指標變數>－－;
　　指標變數的自減運算是將指標變數指向上一元素的運算。當計算機執行 <指標變數>－－ 指令後，指標變數實際減少為指標變數型別位元組數，即：
　　<指標變數>=<指標變數>－sizeof(<指標變數型別>)
　　自加運算和自減運算既可後置，也可前置。
　　（3）指標變數加n運算
　　指令格式：<指標變數>=<指標變數>+n;
　　指標變數的加n運算是將指標變數指向下n個元素的運算。當計算機執行 <指標變數>+ n 指令後，指標變數實際增加值為指標變數型別位元組數乘以n，即：
<指標變數>=<指標變數>+sizeof(<指標變數型別>)*n
　　（4）指標變數減n運算
　　指令格式：<指標變數>=<指標變數>－n;
　　指標變數的減n運算是將指標變數指向上n個元素的運算。當計算機執行 <指標變數>－ n 指令後，指標變數實際減少值為指標變數型別位元組數乘以n，即：
　　<指標變數>=<指標變數>－sizeof(<指標變數型別>)*n
【例7.3】指標變數的自加、自減、加n和減n運算。假設陣列a的首位址為1000，如圖7.4所示。


　# include <iostream.h>
　void main( void)
　{ int a[5]={0,1,2,3,4};
　　int *p;
　　p=&a[0]; //p指向a[0]，p=1000
　　p++ ; //p指向下一個元素a[1]，p=1004
　　cout<< *p<<'\t'; //輸出a[1]的內容1。
　　p=p+3; //p指向下3個元素a[4]，p=1016 
　　cout<< *p<<'\t'; //輸出a[4]的內容4。
　　p－－; //p指向上一個元素a[3]，p=1012
　　cout<< *p<<'\t'; //輸出a[3]的內容3。
　　p=p－3; //p指向上3個元素a[0],p=1000
　　cout<< *p<<'\t'; //輸出a[0]的內容0。
　}
　　程式執行後輸出：
　　1 4 3 0
　　從上例可以看出，通過對指標變數的加減算術運算，可以達到移動指標變數指向下n個元素單元或向上n個元素單元的目的。

3．指標變數的關系運算
　　指標變數的關系運算是指標變數值的大小比較，即對兩個指標變數內的位址進行比較，主要用於對陣列元素的判斷。


　　【例7.4】用指標變數求一維實型陣列元素和，並輸出陣列每個元素的值及陣列和。
　# include <iostream.h>
　void main( void )
　{ int a[5]={1,2,3,4,5};
　　int *p,*p1;
　　p1=&a[4]+1;
　　for (p=&a[0];p<p1;p++) 
　　cout <<*p<<'\t';
　　int sum=0;
　　p=&a[0];
　　while (p!=p1) sum+=*p++;
　　cout <<"\n sum="<<sum<<endl;
　}
　　執行程式後：輸出：
　　1 2 3 4 5 
　　sum=15
　　程式中首先將陣列尾位址+1賦給p1，如圖7.4所示。在for 語句中，指標變數p為迴圈變數，陣列首位址&a[0]賦給p。迴圈時先將迴圈控制變數p與p1中位址比較，若p<p1，則以*p方式輸出陣列元素a[i]的值，並將p自加指向下一個元素。此迴圈直到p□p1為止。
　　在while語句中，仍用p作為迴圈控制變數，當p!=p1時，用sum=sum+*p;語句將陣列元素值累加到sum中去，同時用 p++語句使指標變數p指向下一個元素，迴圈直到p=p1為止，最後輸出陣列元素之和。

4．指標運算符的混合運算與優先級


　　（1）指標運算符* 與取位址運算符&的優先級相同，按自右向左的方向結合。
　　設有變數定義語句： int a, *p=&a; 
　　則運算式：&*p 的求值順序為先"*"後"&"，即& (*p)=&a=p 。
　　而運算式：*&a 的求值順序為先"&"後"*"，即* (&a)=*p=a 。
　　（2）"++"、"－－"、"*"、"&"的優先級相同，按自右向左方向結合。下面結合例子加以說明。設有變數定義語句：
　　int a[4]={100,200,300,400},b;
　　int * p=&a[0]; 
　　為了敘述方便，假設系統給陣列a配置的首位址為1000，如圖7.4所示。
　　１ b=*p++; 
　　按自右向左結合的原則，運算式 *p++ 求值序順為先"++"後"*"，即：*(p++)。由於"++"在p之後為後置++運算符，所以運算式的實際操作是先取*p值，後進行p++的自加操作。即賦值運算式 b=*p++; 等同於下面兩條語句： 
　　b=*p; // b=*p=a[0]=100
　　p++; //p=p+sizeof(int)= 1004
　　最後運算的結果為b=100,p=1004指向a[1]。
　　２ b=*++p; 
　　按自右向左結合的原則，運算式 *++p 求值順序為先"++"後"*"，即：*(++p)。由於++在p之前為前置++運算符，所以運算式的實際操作是進行++p的自加操作，後取*p值。即賦值運算式 b=*++p; 等同於下面兩條語句： 
　　++p; //p=p+sizeof(int)= 1008，指向a[2]
　　b=*p; // b=*p=a[2]=300
　　最後運算的結果為b=300,p=1008指向a[2]。

３ b=(*p)++; 
　　由於括號內優先運算，所以運算式先取出*p（即a[2]）的值並賦給b，然後將*p的值即a[2]內容加1。所以運算式等同於下面兩條語句：
　　b=*p; //b=a[2]=300 
　　a[2]++ ; // a[2]=300+1=301
　　４ b=*(p++); 
　　由１可知，該運算式等同於*p++，運算結果為：
　　b=*p; //b=a[2]=301
　　p++; // p=p+sizeof(int)=1012，指向a[3]
　　５ b=++*p ;
　　該運算式先進行"*"運算，再進行"++"運算，即先取出*p的值，再將該值加1。因此運算式實際進行了如下運算：b=++(*p)=++a[3]=400+1=401; p仍指向a[3]不變。
　　將上述討論中各語句匯總為例題如下：


 

　　【例7.5】指標運算符"*"、"&"、"++"優先級與結合律示例。
　# include <iostream.h>
　main()
　{ int a[4]={100,200,300,400},b;
　　int *p=&a[0];
　　cout<<'\t'<<"p="<<p<<endl;
　　b=*p++;
　　cout<<"b="<<b<<'\t'<<"p="<<p<<endl;
　　b=*++p;
　　cout<<"b="<<b<<'\t'<<"p="<<p<<endl;
　　b=(*p)++;
　　cout<<"b="<<b<<'\t'<<"p="<<p<<endl;
　　b=*(p++);
　　cout<<"b="<<b<<'\t'<<"p="<<p<<endl;
　　b=++*p;
　　cout<<"b="<<b<<'\t'<<"p="<<p<<endl;
　　}
　　運行結果為：
　　p=0x0065FDE8
　　b=100 p=0x0065FDEC
　　b=300 p=0x0065FDF0
　　b=300 p=0x0065FDF0
　　b=301 p=0x0065FDF4
　　b=401 p=0x0065FDF4
　　說明：在定義陣列時，資料a的位址是由作業系統 儲存管理動態配置的，因此，陣列a的位址是不確定的，每次運行的結果都可能會不同。一般用十六進制數表示。本例中系統為陣列a配置的首位址為0x0065FDE8。而在圖7.4中所假設的位址1000~1016完全是為了便於讀者理解。













